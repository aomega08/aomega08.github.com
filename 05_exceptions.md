# SYSCALL and Exceptions

If you keep implementing instructions, eventually you end up on a `SYSCALL`. The `SYSCALL` is a weird instruction because it essentially triggers a CPU exception.

Exceptions exist in a form or another in all CPUs. They are usually the result of software errors, like a division by zero, or a hardware interrupt, like an hard disk reporting that it is done reading data.

Different CPUs have different ways of reporting _what_ is the error or the interrupt that occurred. For example on x86 CPUs, the Program Counter (or Intruction Pointer) is set to a different address depending on the exception.

On MIPS, instead, the PC is immediately set to 8000_0080 and a value is written in register #13 of COP0 (known as Cause) that represents the type of exception.

Notice that the 8000_0080 address in in KSEG0, which means that the CPU must be in Kernel mode to run it. Not of a big issue, given that the MIPS will force itself out of User mode if it's running in it, when handling an exception.

## A note about the Status Register

Remember our old friend cop0r12 (aka the Status Register)? Last time we were only concerned about bit #16 that connects and disconnects the memory bus. This time, let's focus on bits #0 and #1.

Bit #0 enables and disabled interrupts (not exceptions - the difference being that interrupts are generated by devices).
Bit #1 puts the CPU in Kernel and User mode.

When an exception comes, you want to be in Kernel mode and with exception disabled (writing 00 to those two bits). As you really don't want an interrupt to come while you're managing a divison by zero or a page fault.

But, at the same time, you want to remember the old value of those two bits, so that when you're done you can restore them. So the sneaky MIPS uses bits #2 and #3 to keep a backup of bits #0 and #1. Even better, you may have disabled interrupts but you may still get a second exception (a division by zero while you handle a division by zero). So bits #4 and #5 are backups of #2 and #3 if that happens. If a fourth exception happens, well f\*\*k you.

The `RFE` (Restore From Exception) instruction will take care of shifting those bits in the old position when an exception handler has terminated.

## Exceptions in the branch delay slot

When an exception handler has completed its execution it will jump back to the old Program Counter, stored in COP0 register #14 (EPC). This as a tiny issue with branch delay slots.

Let's say a Hardware Interrupt fires while branch delay slot is being executed. The branching instruction has already been executed and if things were continuing normally, the branch would have been taken, meaning that the Delay Slot instruction would be executed and then execution would continue at the branch target.

But, if the interrupt fired during the branch delay slot execution, the EPC register will contain it's address. Continuing execution there means that the branch will be ignored, taking a different path from what was initially scheduled.

For this reason, exceptions firing during branch delay slot will put `PC - 4` in the EPC register.

### SYSCALL again

Two funny behaviours about this instruction:

* You should never put a SYSCALL instruction after a jump or branch (in the delay slot), because since execution will continue there, you would end up in a loop of SYSCALLs.
* Even though a SYSCALL effectively jumps to 8000_0080, it **does not** have a branch delay slot. All that mess about the superscalar architecture pipeline is ignored and the pipeline is emptied.

## More instructions

On our way to get the Sony Boot Logo (imagine that!), we encounter a few more unimplemented instructions, which we'll proceed to address (and others that I implemented anyway):

* **`BLTZ`**: Branch on Less Than Zero.
* **`BGEZ`**: Branch on Greather Than or Equal to Zero.
* **`DIV`**: Signed Division.
* **`DIVU`**: Unsigned Division.
* **`LH`**: Load Halfword from memory and sign extend it.
* **`LHU`**: Load Halfword from memory.
* **`MTHI`, `MTLO`, `MFHI`, `MFLO`**: Move to/from HI and LO registers (more on this soon).
* **`MULT`**: Signed Multiplication.
* **`MULTU`**: Unsigned Multiplication.
* **`NOR`**: Not OR.
* **`SLLV`**: Shift Left Logical Value (Shift left with amount in a register).
* **`SLT`**: Set on Less Than Register (compare with value and store result).
* **`SLTI`**: Set on Less Than Immediate (compare with value and store result).
* **`SRL`**: Shift Right Logic (Shift right, zero-extending, with immediate amount).
* **`SRLV`**: Shift Right Logic (Shift right, zero-extending, with amount in a register).
* **`SRAV`**: Shift Right Arithmetic Value (Shift right, sign-extending, with amount in a register).
* **`SUB`**: Subtract with exception on overflow.
* **`SYSCALL`**: Trigger a CPU Exception with Cause 0x20.
* **`XOR`**: XOR with operands in registers.
* **`XORI`**: XOR with Immediate.

## Multiplication and Division

The Multiplication and Division work quite differently from the other operations on the MIPS. First of all they do not store the results in another regular register. For example you cannot do `MULT r1, r2, r3` and expect r1 to contain r2 * r3. This is because multiplying two 32-bit numbers will have a 64-bit result which cannot fit in a 32-bit register.

For this reason two additional registers called LO and HI have been added, that contain respectively the LOW 32-bits and the HIGH 32-bits of a multiplication result (surprise!). Division will still use both LO and HI, but for different purposes (dividing 32-bit by 32-bit will give you 32-bit in the worst case). The LO register will contain the integer division result (5 / 2 = 2), and the HI register will have the reminder of the division, or the modulo (5 % 2 = 1).

Moving data to and from these registers is done with the MTLO, MTHI, MFLO, MFHI operations which take a regular source/target register as a parameter.

For example:

~~~
DIV r1, r2
MFLO r3
~~~

This would run the division between r1 and r3 and store the quotient in r3.

Another peculiarity of these operation is that they run asynchronously. Multiplication and divisions are massively slower compared to all other CPU operations (between 10 and 70 times slower than an ADD for example). So in order to not waste too much time on this, the CPU will start them in the background and continue processing other instructions... until it gets to a MFLO or MFHI, which, needing the result to be available will stall the CPU completely until the multiplication or division is done. This behaviour doesn't need to be emulated (except for accurate timing, which may be nice).

## What happens now

If you did everything right, and assuming I did... You will see something like this:

~~~
W [IO] Read from unknown I/O location 10f0
W [IO] Write to unknown I/O location 10f0 - value: b0000
W [IO] Read from unknown I/O location 1814
W [IO] Write to unknown I/O location 1810 - value: e1001000
W [IO] Read from unknown I/O location 1814
W [IO] Write to unknown I/O location 1810 - value: e1001000
W [IO] Read from unknown I/O location 1814
W [IO] Write to unknown I/O location 1810 - value: e1001000
W [IO] Read from unknown I/O location 1814
W [IO] Write to unknown I/O location 10f4 - value: 0
W [IO] Read from unknown I/O location 10f4
W [IO] Write to unknown I/O location 10f4 - value: 4840000
W [IO] Read from unknown I/O location 1814
W [IO] Read from unknown I/O location 1814
W [IO] Read from unknown I/O location 1814
[... that same line forever ...]
~~~

So registers 10f0 and 10f4 are DMA registers and 1010 and 1014 are GPU registers! Finally the BIOS is starting to draw something. So Exciting! But it also ends up in an infinite loop reading from 1814.

Oh and between all that it also reads and writes on a huge amount of SPU registers. As I said before, I'm going to skip the SPU for now as I don't know anything about sound processing, so I have filtered those registers out.

So, for next chapter, DMA it is.

## Show me the code!

You can checkout the code at this stage on [Github](https://github.com/aomega08/psemu/tree/18063e1efa867b0f2108c6b8e33ee72962edddcd).
